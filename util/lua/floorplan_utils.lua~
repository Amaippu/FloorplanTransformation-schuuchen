require 'csvigo'
require 'image'
local pl = require 'pl.import_into' ()
cv = require 'cv'
require 'cv.imgproc'

local utils = {}

function utils.getNumberMap()
   if not utils.numberMap then
      local numberMap = {}
      numberMap.labels = {}
      numberMap.labels['living_room'] = 1
      numberMap.labels['kitchen'] = 2
      numberMap.labels['bedroom'] = 3
      numberMap.labels['bathroom'] = 4
      numberMap.labels['restroom'] = 5
      numberMap.labels['balcony'] = 6
      numberMap.labels['closet'] = 7
      numberMap.labels['corridor'] = 8
      numberMap.labels['washing_room'] = 9
      numberMap.labels['PS'] = 10
      
      numberMap.icons = {}
      numberMap.icons['bathtub'] = {1}
      numberMap.icons['cooking_counter'] = {2, 3}
      numberMap.icons['toilet'] = {4}
      numberMap.icons['entrance'] = {5}
      numberMap.icons['washing_basin'] = {6, 7, 8, 9}
      numberMap.icons['special'] = {10, 11, 12}
      numberMap.icons['stairs'] = {13}

      numberMap.doors = {}
      numberMap.doors['door'] = 1
      utils.numberMap = numberMap
   end
   return utils.numberMap
end

function utils.getNumber(mode, itemInfo)
   local numberMap = utils.getNumberMap()
   if mode == 'points' then
      return (itemInfo[2] - 1) * 4 + itemInfo[3]
   elseif mode == 'doors' then      
      return itemInfo[2]
   elseif mode == 'icons' then
      return numberMap[mode][itemInfo[1]][itemInfo[2]]
   elseif mode == 'labels' then
      return numberMap[mode][itemInfo[1]]
   else
      assert(false)
   end
end

function utils.getNameMap()
   if not utils.nameMap then
      local nameMap = {}
      local numberMap = utils.getNumberMap()
      for mode, map in pairs(numberMap) do
	 nameMap[mode] = {}
	 for name, number in pairs(map) do
	    if type(number) == "table" then
	       for _, num in pairs(number) do
		  nameMap[mode][num] = {name, _, 1}
	       end
	    else
	       nameMap[mode][number] = {name, 1, 1}
	    end
	 end
      end
      utils.nameMap = nameMap
   end
   return utils.nameMap
end

function utils.getItemInfo(mode, number)
   local nameMap = utils.getNameMap()
   if mode == 'points' then
      return {'point', math.floor((number - 1) / 4) + 1, (number - 1) % 4 + 1}
   elseif mode == 'doors' then
      return {'door', number, 1}
   elseif mode == 'icons' then
      number = math.min(number, #nameMap[mode])
      return nameMap[mode][number]
   elseif mode == 'labels' then
      number = math.min(number, #nameMap[mode])
      return nameMap[mode][number]
   else
      assert(false)
   end
end

function utils.keyMap()
   local keyMap = {}
   keyMap['b'] = {'icons', 'bathtub'}
   keyMap['c'] = {'icons', 'cooking_counter'}
   keyMap['t'] = {'icons', 'toilet'}
   keyMap['q'] = {'icons', 'special'}
   keyMap['e'] = {'icons', 'entrance'}
   keyMap['w'] = {'icons', 'washing_basin'}
   keyMap['s'] = {'icons', 'stairs'}
   for i = 1, 10 do
      keyMap[tostring(i % 10)] = {'labels', utils.getItemInfo('labels', i)[1]}
   end
   keyMap['a'] = {'walls', 'wall'}
   keyMap['d'] = {'doors', 'door'}

   return keyMap
end

function utils.modeMap()
   local modeMap = {}
   local keyMap = utils.keyMap()
   for _, modeNamePair in pairs(keyMap) do
      modeMap[modeNamePair[2]] = modeNamePair[1]
   end
   return modeMap
end

function utils.numItemsPerCell()
   local numItemsPerCell = {}
   numItemsPerCell.points = 2
   numItemsPerCell.doors = 2
   numItemsPerCell.icons = 2
   numItemsPerCell.labels = 2
   return numItemsPerCell
end

function utils.numItemsGlobal()
   local numItemsGlobal = {}
   numItemsGlobal['bathtub'] = 1
   numItemsGlobal['cooking_counter'] = 1
   numItemsGlobal['toilet'] = 2
   numItemsGlobal['special'] = 4
   numItemsGlobal['entrance'] = 1
   numItemsGlobal['washing_basin'] = 4
   numItemsGlobal['stairs'] = 4
   
   numItemsGlobal['living_room'] = 1
   numItemsGlobal['kitchen'] = 1
   numItemsGlobal['bedroom'] = 4
   numItemsGlobal['bathroom'] = 1
   numItemsGlobal['restroom'] = 2
   numItemsGlobal['balcony'] = 2
   numItemsGlobal['closet'] = 4
   numItemsGlobal['corridor'] = 1
   numItemsGlobal['washing_room'] = 1
   numItemsGlobal['PS'] = 2
   
   return numItemsGlobal
end

function utils.numFeaturesPerItem()
   local numFeaturesPerItem = {}
   numFeaturesPerItem.points = 5
   numFeaturesPerItem.doors = 5
   numFeaturesPerItem.icons = 5
   numFeaturesPerItem.labels = 5
   return numFeaturesPerItem
end

function utils.offsetsBB()
   local numItemsPerCell = utils.numItemsPerCell()
   local numFeaturesPerItem = utils.numFeaturesPerItem()
   local offsetsBB = {}
   offsetsBB.points = 0
   offsetsBB.doors = offsetsBB.points + numFeaturesPerItem.points * numItemsPerCell.points
   offsetsBB.icons = offsetsBB.doors + numFeaturesPerItem.doors * numItemsPerCell.doors
   offsetsBB.labels = offsetsBB.icons + numFeaturesPerItem.icons * numItemsPerCell.icons
   return offsetsBB
end

function utils.numFeaturesBB()
   local numItemsPerCell = utils.numItemsPerCell()
   local offsetsBB = utils.offsetsBB()
   local numFeaturesPerItem = utils.numFeaturesPerItem()
   local numFeaturesBB = offsetsBB.labels + numFeaturesPerItem.labels * numItemsPerCell.labels
   return numFeaturesBB
end

function utils.offsetsClass()
   local numItemsPerCell = utils.numItemsPerCell()
   local numFeaturesBB = utils.numFeaturesBB()
   local offsetsClass = {}
   offsetsClass.points = numFeaturesBB
   offsetsClass.doors = offsetsClass.points + numItemsPerCell.points
   offsetsClass.icons = offsetsClass.doors + numItemsPerCell.doors
   offsetsClass.labels = offsetsClass.icons + numItemsPerCell.icons
   return offsetsClass
end

function utils.numFeaturesClass()
   local numItemsPerCell = utils.numItemsPerCell()
   local numFeaturesClass = numItemsPerCell.points + numItemsPerCell.doors + numItemsPerCell.icons + numItemsPerCell.labels
   return numFeaturesClass
end

function utils.findConnectedComponents(mask)
   local maskByte = (mask * 255):byte()   
   local components = torch.IntTensor(maskByte:size())
   local numComponents = cv.connectedComponents{maskByte, components}
   return components, numComponents
end

function utils.drawSegmentation(floorplanComponent, numComponents, denotedColorMap)
   local numComponents = numComponents or torch.max(floorplanComponent)
   local colorMap = denotedColorMap
   if colorMap == nil then
      colorMap = {}
      for i = 1, numComponents do
         colorMap[i] = torch.rand(3)
      end
   end
   colorMap[0] = torch.zeros(3)      
   colorMap[-1] = torch.ones(3)      

   local floorplanLabels = floorplanComponent:repeatTensor(3, 1, 1):double()
   for c = 1, 3 do
      floorplanLabels[c]:apply(function(x) return colorMap[x][c] end)
   end
   return floorplanLabels
end

function loadIcon(iconName, iconStyle, iconOrientation)
   local icon = image.load('../icons/' .. iconName .. '_' .. iconStyle .. '.jpg', 1)
   assert(icon ~= nil)
   return rotateIcon(icon, iconOrientation)
end

function rotateIcon(iconOriginal, iconOrientation)
   local iconRotated
   if iconOrientation == 1 then
      iconRotated = iconOriginal:clone()
   elseif iconOrientation == 2 then
      if iconOriginal:dim() == 2 then
         iconRotated = image.hflip(iconOriginal:transpose(1, 2):contiguous())
      else
	 iconRotated = image.hflip(iconOriginal:transpose(2, 3):contiguous())
      end
   elseif iconOrientation == 3 then
      iconRotated = image.vflip(image.hflip(iconOriginal))
   else
      if iconOriginal:dim() == 2 then
	 iconRotated = image.vflip(iconOriginal:transpose(1, 2):contiguous())
      else
	 iconRotated = image.vflip(iconOriginal:transpose(2, 3):contiguous())
      end
   end
   return iconRotated
end

function utils.loadIconImages()
   if utils.iconImages == nil then
      utils.iconImages = {}
      local numberMap = utils.getNumberMap()
      for mode, map in pairs(numberMap) do
	 for name, number in pairs(map) do
	    utils.iconImages[name] = {}
	    for style = 1, 13 do
	       local iconExists, icon = pcall(function()
                     return loadIcon(name, style, 1)
	       end)
	       if iconExists == false then
		  break
	       end
	       utils.iconImages[name][style] = icon
	    end
	 end
      end
   end
   return utils.iconImages
end

function utils.lineDim(line)
   if math.abs(line[1][1] - line[2][1]) > math.abs(line[1][2] - line[2][2]) and math.abs(line[1][2] - line[2][2]) <= 1 then
      return 1
   elseif math.abs(line[1][2] - line[2][2]) > math.abs(line[1][1] - line[2][1]) and math.abs(line[1][1] - line[2][1]) <= 1 then
      return 2
   else
      return 0
   end
end

function utils.cutoffRange(range, max)
   local lowerBound = math.max(range[1], 1)
   local upperBound = math.min(range[2], max)
   if lowerBound > upperBound then
      return {}
   else
      return {lowerBound, upperBound}
   end
end

function utils.drawLineMask(width, height, lines, lineWidth, indexed, denotedLineDim)
   local lineWidth = lineWidth or 5
   local indexed = indexed or false
   
   local lineMask = torch.zeros(height, width)
   local size = {width, height}
   local index = 1
   for _, line in pairs(lines) do
      local lineDim = utils.lineDim(line)
      if (not denotedLineDim and lineDim > 0) or lineDim == denotedLineDim then
         local fixedDim = 3 - lineDim
         local fixedValue = (line[1][fixedDim] + line[2][fixedDim]) / 2
         local fixedRange = utils.cutoffRange({fixedValue - lineWidth, fixedValue + lineWidth}, size[fixedDim])
         if #fixedRange > 0 then
            local lineRange = utils.cutoffRange({line[1][lineDim] - lineWidth, line[2][lineDim] + lineWidth}, size[lineDim])
            if lineDim == 1 then
               lineMask[{{fixedRange[1], fixedRange[2]}, {lineRange[1], lineRange[2]}}] = index
            else
               lineMask[{{lineRange[1], lineRange[2]}, {fixedRange[1], fixedRange[2]}}] = index
            end
	    if indexed then
	       index = index + 1
	    end
         end
      end
   end
   return lineMask
end

function utils.sortLines(lines)
   for lineIndex, line in pairs(lines) do
      local lineDim = utils.lineDim(line)
      if lineDim > 0 and line[1][lineDim] > line[2][lineDim] then
         local temp = lines[lineIndex][1][lineDim]
         lines[lineIndex][1][lineDim] = lines[lineIndex][2][lineDim]
         lines[lineIndex][2][lineDim] = temp
      end
   end
   return lines
end

function utils.calcDistance(point_1, point_2)
   return math.sqrt(math.pow(point_1[1] - point_2[1], 2) + math.pow(point_1[2] - point_2[2], 2))
end

function utils.findNearestEndPointPair(line_1, line_2, gap)
   local nearestPair
   local minDistance
   for index_1 = 1, 2 do
      for index_2 = 1, 2 do
         local distance = utils.calcDistance(line_1[index_1], line_2[index_2])
         if minDistance == nil or distance < minDistance then
            nearestPair = {index_1, index_2}
            minDistance = distance
         end
      end
   end
   if minDistance > gap then
      local lineDim_1 = utils.lineDim(line_1)
      local lineDim_2 = utils.lineDim(line_2)
      local fixedValue_1 = (line_1[1][3 - lineDim_1] + line_1[2][3 - lineDim_1]) / 2        
      local fixedValue_2 = (line_2[1][3 - lineDim_2] + line_2[2][3 - lineDim_2]) / 2
      if lineDim_1 + lineDim_2 == 3 then
         if line_2[1][lineDim_2] < fixedValue_1 and line_2[2][lineDim_2] > fixedValue_1 then
            for index = 1, 2 do
               local distance = math.abs(line_1[index][lineDim_1] - fixedValue_2)      
               if distance < minDistance then          
                  nearestPair = {index, 0}     
                  minDistance = distance       
               end
            end
         end
         if line_1[1][lineDim_1] < fixedValue_2 and line_1[2][lineDim_1] > fixedValue_2 then
            for index = 1, 2 do
               local distance = math.abs(line_2[index][lineDim_2] - fixedValue_1)      
               if distance < minDistance then          
                  nearestPair = {0, index}
                  minDistance = distance
               end
            end
         end
      end
   end
   if #line_1 >= 3 and line_1[3][2] == 2 and line_2[3][2] == 1 then
      nearestPair[2] = 0   
   end
   if #line_2 >= 3 and line_2[3][2] == 2 and line_1[3][2] == 1 then   
      nearestPair[1] = 0   
   end
   return nearestPair, minDistance
end

function utils.stitchLines(lines, gap)
   for lineIndex_1, line_1 in pairs(lines) do
      local lineDim_1 = utils.lineDim(line_1)
      if lineDim_1 > 0 then
	 local fixedValue_1 = (line_1[1][3 - lineDim_1] + line_1[2][3 - lineDim_1]) / 2
	 for lineIndex_2, line_2 in pairs(lines) do
	    if lineIndex_2 > lineIndex_1 then
	       local lineDim_2 = utils.lineDim(line_2)
	       if lineDim_2 > 0 then
		  local fixedValue_2 = (line_2[1][3 - lineDim_2] + line_2[2][3 - lineDim_2]) / 2
		  local nearestPair, minDistance = utils.findNearestEndPointPair(line_1, line_2, gap)
		  --print(minDistance .. ' ' .. lineDim_1 .. ' ' .. lineDim_2)
		  if minDistance <= gap and lineDim_1 + lineDim_2 == 3 then
		     local pointIndex_1 = nearestPair[1]
		     local pointIndex_2 = nearestPair[2]
		     --print(lineIndex_1 .. ' ' .. lineIndex_2)
		     if pointIndex_1 > 0 and pointIndex_2 > 0 then
			lines[lineIndex_1][pointIndex_1][lineDim_1] = fixedValue_2
			lines[lineIndex_2][pointIndex_2][lineDim_2] = fixedValue_1
		     elseif pointIndex_1 > 0 and pointIndex_2 == 0 then
			lines[lineIndex_1][pointIndex_1][lineDim_1] = fixedValue_2
		     elseif pointIndex_1 == 0 and pointIndex_2 > 0 then
			lines[lineIndex_2][pointIndex_2][lineDim_2] = fixedValue_1
		     end
		  end
	       end
	    end
	 end
      end
   end
   return lines
end

function utils.fixedDoors(lines, walls, gap)
   for lineIndex_1, line_1 in pairs(lines) do
      local lineDim = utils.lineDim(line_1)
      if lineDim > 0 then
         local fixedValue_1 = (line_1[1][3 - lineDim] + line_1[2][3 - lineDim]) / 2
	 local doorFixed = false
         for lineIndex_2, line_2 in pairs(walls) do
	    if utils.lineDim(line_2) == lineDim then
	       local fixedValue_2 = (line_2[1][3 - lineDim] + line_2[2][3 - lineDim]) / 2
	       if math.abs(fixedValue_2 - fixedValue_1) <= gap and math.min(line_1[1][lineDim], line_1[2][lineDim]) >= math.min(line_2[1][lineDim], line_2[2][lineDim]) - gap and math.max(line_1[1][lineDim], line_1[2][lineDim]) <= math.max(line_2[1][lineDim], line_2[2][lineDim]) + gap then
		  for c = 1, 2 do
		     line_1[c][3 - lineDim] = fixedValue_2
		  end
		  doorFixed = true
               end
            end
         end
	 if doorFixed == false then
	    print('door: ' .. lineIndex_1 .. ' not fixed')
	 end
      end
   end
   return lines
end

function utils.gridPoint(width, height, gridWidth, gridHeight, point)
   local cellWidth = width / gridWidth   
   local cellHeight = height / gridHeight   
   local gridX = math.floor((point[1] - 1) / cellWidth) + 1   
   local gridY = math.floor((point[2] - 1) / cellHeight) + 1
   local cellX = ((point[1] - 1) - (gridX - 1) * cellWidth) / (cellWidth - 1)
   local cellY = ((point[2] - 1) - (gridY - 1) * cellHeight) / (cellHeight - 1)
   return {{gridX, gridY}, {cellX, cellY}}
end

function utils.gridRectangle(width, height, gridWidth, gridHeight, rectangle)
   --[[
   if point_2 == nil then
      local rectangle = utils.gridPoint(width, height, gridWidth, gridHeight, point_1)
      table.insert(rectangle, {0, 0})
      return rectangle
      end
   ]]--
   local point_1 = rectangle[1]
   local point_2 = rectangle[2]
   local center = utils.gridPoint(width, height, gridWidth, gridHeight, {(point_1[1] + point_2[1]) / 2, (point_1[2] + point_2[2]) / 2})
   local rectangle = center
   table.insert(rectangle, {(point_2[1] - point_1[1] + 1) / width, (point_2[2] - point_1[2] + 1) / height})
   return rectangle
end

function utils.imageRectangle(width, height, gridWidth, gridHeight, rectangle)
   local cellWidth = width / gridWidth   
   local cellHeight = height / gridHeight   
   local centerX = (rectangle[1][1] - 1) * cellWidth + rectangle[2][1] * (cellWidth - 1) + 1
   local centerY = (rectangle[1][2] - 1) * cellHeight + rectangle[2][2] * (cellHeight - 1) + 1
   return {{math.max(torch.round(centerX - (rectangle[3][1] * (width - 1)) / 2), 1), math.max(torch.round(centerY - (rectangle[3][2] * (height - 1)) / 2), 1)}, {math.min(torch.round(centerX + (rectangle[3][1] * (width - 1)) / 2), width), math.min(torch.round(centerY + (rectangle[3][2] * (height - 1)) / 2), height)}}
end

function utils.pointsToLines(width, height, points, lineWidth)
   local usedPointLineMask = {}
   local pointOrientations = {}
   for pointIndex, point in pairs(points) do
      usedPointLineMask[pointIndex] = {true, true, true, true}
      
      local orientations = {}
      local orientation = point[3][3]
      if point[3][2] == 1 then
         table.insert(orientations, (orientation + 2 - 1) % 4 + 1)
      elseif point[3][2] == 2 then       
         table.insert(orientations, orientation)                 
         table.insert(orientations, (orientation + 3 - 1) % 4 + 1)
      elseif point[3][2] == 3 then
         table.insert(orientations, (orientation + 2 - 1) % 4 + 1)
         --[[
            for i = 1, 4 do         
            if i ~= orientation then
            table.insert(orientations, i)                             
            end          
            end
         ]]--
      else
         --[[
            for i = 1, 4 do         
            table.insert(orientations, i)                             
            end
         ]]--
      end
      pointOrientations[pointIndex] = orientations
      for _, orientation in pairs(orientations) do
         usedPointLineMask[pointIndex][orientation] = false
      end
   end
   
   local lines = {}
   for pointIndex, point in pairs(points) do
      local orientations = pointOrientations[pointIndex]
      
      local x = point[1][1]
      local y = point[1][2]
      for _, orientation in pairs(orientations) do
         if usedPointLineMask[pointIndex][orientation] == false then
            local lineDim
            local fixedValue
            local endPoint
            local startPoint
            if orientation == 1 or orientation == 3 then
               lineDim = 2
               fixedValue = x
               startPoint = y
               if orientation == 1 then
                  endPoint = 1
               else
                  endPoint = height
               end
            else
               lineDim = 1
               fixedValue = y
               startPoint = x
               if orientation == 4 then
                  endPoint = 1
               else
                  endPoint = width
               end
            end
            local orientationOpposite = (orientation + 2 - 1) % 4 + 1
            local selectedOtherPointIndex
            for otherPointIndex, otherPoint in pairs(points) do
               if otherPointIndex ~= pointIndex and usedPointLineMask[otherPointIndex][orientationOpposite] == false then
                  local otherXY = otherPoint[1]
                  if otherXY[lineDim] > math.min(endPoint, startPoint) and otherXY[lineDim] < math.max(endPoint, startPoint) and otherXY[3 - lineDim] >= fixedValue - lineWidth and otherXY[3 - lineDim] <= fixedValue + lineWidth then
                     endPoint = otherXY[lineDim]
                     selectedOtherPointIndex = otherPointIndex
                  end
               end
            end

            local point_1 = {}
            point_1[lineDim] = math.min(startPoint, endPoint)
            point_1[3 - lineDim] = fixedValue
            local point_2 = {}
            point_2[lineDim] = math.max(startPoint, endPoint)
            point_2[3 - lineDim] = fixedValue

            if point_1[1] ~= 1 and point_1[1] ~= width and point_1[2] ~= 1 and point_1[2] ~= height and point_2[1] ~= 1 and point_2[1] ~= width and point_2[2] ~= 1 and point_2[2] ~= height then
               table.insert(lines, {point_1, point_2, {"wall", 1, 1}})
            end
            
            if selectedOtherPointIndex ~= nil then
               usedPointLineMask[selectedOtherPointIndex][orientationOpposite] = true
            end
            usedPointLineMask[pointIndex][orientation] = true
         end
      end
   end
   return lines
end

function utils.convertRepresentationToGeneral(width, height, representation, representationType, lineWidth)
   local representationGeneral = {}
   if representationType == 'P' then

      representationGeneral.walls = utils.pointsToLines(width, height, representation.points, lineWidth)
      
      local lineMask = torch.zeros(height, width)
      for _, line in pairs(representationGeneral.walls) do
         local lineDim = utils.lineDim(line)
         if lineDim > 0 then
            local maxSize = {width, height}
            local rectangle = {{}, {}}
            rectangle[1][lineDim] = math.min(line[1][lineDim], line[2][lineDim])            
            rectangle[2][lineDim] = math.max(line[1][lineDim], line[2][lineDim])
            rectangle[1][3 - lineDim] = math.max((line[1][3 - lineDim] + line[2][3 - lineDim]) / 2 - lineWidth, 1)
            rectangle[2][3 - lineDim] = math.min((line[1][3 - lineDim] + line[2][3 - lineDim]) / 2 + lineWidth, maxSize[3 - lineDim])

	       --[[
	    for pointIndex = 1, 2 do
	       for c = 1, 2 do
		  print(rectangle[pointIndex][c])
	       end
	    end
		  print(#lineMask)
	       ]]--
	    
	       --representationImage[{{}, {rectangle[1][2], rectangle[2][2]}, {rectangle[1][1], rectangle[2][1]}}] = 0
            lineMask[{{rectangle[1][2], rectangle[2][2]}, {rectangle[1][1], rectangle[2][1]}}] = 1
            --success, newRepresentationImage = pcall(function() return image.drawRect(representationImage, rectangle[1][1], rectangle[1][2], rectangle[2][1], rectangle[2][2], {lineWidth = lineWidth, color = {0, 0, 0}}) end)
            --if success then               
            --representationImage = newRepresentationImage               
            --end
         end
         --representationImage[{{}, {minX, maxX}, {minY, maxY}}] = 0
      end
      
      for mode, items in pairs(representation) do
         if mode == 'doors' or mode == 'icons' or mode == 'labels' then
            for __, item in pairs(items) do
               --print(mode)
               --print(item)
               --local iconImage = iconImages[item[3][1]][item[3][2]]
               if mode == 'icons' then
		  local orientation = 1        
                  local rectangle = {item[1], item[2]}
		  if (math.abs(rectangle[2][1] - rectangle[1][1]) >= math.abs(rectangle[2][2] - rectangle[1][2]) and (item[3][1] ~= 'toilet' and item[3][1] ~= 'stairs')) or (math.abs(rectangle[2][1] - rectangle[1][1]) <= math.abs(rectangle[2][2] - rectangle[1][2]) and (item[3][1] == 'toilet' or item[3][1] == 'stairs')) then
                     local min = math.min(rectangle[1][2], rectangle[2][2])
                     local max = math.max(rectangle[1][2], rectangle[2][2])
                     local center = (rectangle[1][1] + rectangle[2][1]) / 2
                     local deltaMin = 0
                     for delta = 1, min - 1 do
                        deltaMin = delta
                        if lineMask[min - delta][center] == 1 then
                           break             
                        end                  
                     end
                     local deltaMax = 0
                     for delta = 1, height - max do
                        deltaMax = delta
                        if lineMask[max + delta][center] == 1 then
                           break
                        end
                     end
                     if deltaMin > deltaMax then
                        orientation = 1
                     else
                        orientation = 3
                     end
                  else
                     local min = math.min(rectangle[1][1], rectangle[2][1])
                     local max = math.max(rectangle[1][1], rectangle[2][1])
                     local center = (rectangle[1][2] + rectangle[2][2]) / 2
                     local deltaMin = 0
                     for delta = 1, min - 1 do
                        deltaMin = delta
                        if lineMask[center][min - delta] == 1 then
                           break
                        end
                     end
                     local deltaMax = 0
                     for delta = 1, width - max do
                        deltaMax = delta
                        if lineMask[center][max + delta] == 1 then
                           break
                        end
                     end
                     if deltaMin > deltaMax then
                        orientation = 4
                     else
                        orientation = 2
                     end
                  end
		  --[[
		  print(item[3][1])
		  print(math.abs(rectangle[2][1] - rectangle[1][1]))
		  print(math.abs(rectangle[2][2] - rectangle[1][2]))
		     print(orientation)
		  ]]--
		  item[3][3] = orientation
               elseif mode == 'doors' then
		  local lineDim
		  if math.abs(item[2][1] - item[1][1]) > math.abs(item[2][2] - item[1][2]) then
		     item[3][3] = 1
		     lineDim = 1
                  else
		     item[3][3] = 2
		     lineDim = 2
                  end
		  local fixedValue = (item[1][3 - lineDim] + item[2][3 - lineDim]) / 2
		  item[1][3 - lineDim] = fixedValue
		  item[2][3 - lineDim] = fixedValue
	       else
		  item[3][3] = 1
               end

	       if mode ~= 'doors' then
		  item[2][1] = math.max(item[2][1] - item[1][1], 30) + item[1][1]          
		  item[2][2] = math.max(item[2][2] - item[1][2], 30) + item[1][2]
	       end


		  --[[
               iconImage = rotateIcon(iconImage, orientation)

               local icon = image.scale(iconImage, rectangle[2][1] - rectangle[1][1] + 1, rectangle[2][2] - rectangle[1][2] + 1)
               if icon:dim() == 2 then
                  icon = icon:repeatTensor(3, 1, 1)
               end
	       ]]--
	       
               --print(rectangle)
               --print(#icon)
               --print(#representationImage[{{}, {rectangle[1][2], rectangle[2][2]}, {rectangle[1][1], rectangle[2][1]}}])
               --representationImage[{{}, {rectangle[1][2], rectangle[2][2]}, {rectangle[1][1], rectangle[2][1]}}] = icon
            end
            representationGeneral[mode] = items
         end
      end
   end
   return representationGeneral
end

function utils.convertRepresentation(width, height, representationGeneral, representationType, lineWidth)
   local representation = {}
   if representationType == 'P' then
      local points = {}
      local usedLinePointMask = {}      
      for lineIndex, line in pairs(representationGeneral.walls) do      
         usedLinePointMask[lineIndex] = {false, false}                  
      end
      
      for lineIndex_1, line_1 in pairs(representationGeneral.walls) do
         local lineDim_1 = utils.lineDim(line_1)
	 if lineDim_1 > 0 then
	    local fixedValue_1 = (line_1[1][3 - lineDim_1] + line_1[2][3 - lineDim_1]) / 2
	    for lineIndex_2, line_2 in pairs(representationGeneral.walls) do
	       if lineIndex_2 > lineIndex_1 then
		  local lineDim_2 = utils.lineDim(line_2)
		  if lineDim_2 > 0 then
		     local fixedValue_2 = (line_2[1][3 - lineDim_2] + line_2[2][3 - lineDim_2]) / 2
		     local nearestPair, minDistance = utils.findNearestEndPointPair(line_1, line_2, lineWidth)
		     
		     if minDistance <= lineWidth and lineDim_1 + lineDim_2 == 3 then
			local pointIndex_1 = nearestPair[1]
			local pointIndex_2 = nearestPair[2]
			if pointIndex_1 > 0 and pointIndex_2 > 0 then
			   local point = {}                
			   point[lineDim_1] = fixedValue_2                 
			   point[lineDim_2] = fixedValue_1
			   local side = {}
			   side[lineDim_1] = line_1[3 - pointIndex_1][lineDim_1] - fixedValue_2
			   side[lineDim_2] = line_2[3 - pointIndex_2][lineDim_2] - fixedValue_1
			   if side[1] < 0 and side[2] < 0 then                             
			      table.insert(points, {point, point, {'point', 2, 1}})
			   elseif side[1] > 0 and side[2] < 0 then                                                    
			      table.insert(points, {point, point, {'point', 2, 2}})
			   elseif side[1] > 0 and side[2] > 0 then                                                                    
			      table.insert(points, {point, point, {'point', 2, 3}})
			   elseif side[1] < 0 and side[2] > 0 then                                                                    
			      table.insert(points, {point, point, {'point', 2, 4}})
			   end
			   usedLinePointMask[lineIndex_1][pointIndex_1] = true
			   usedLinePointMask[lineIndex_2][pointIndex_2] = true
			elseif (pointIndex_1 > 0 and pointIndex_2 == 0) or (pointIndex_1 == 0 and pointIndex_2 > 0) then
			   local lineDim
			   local pointIndex
			   local fixedValue
			   local pointValue
			   if pointIndex_1 > 0 then
			      lineDim = lineDim_1
			      pointIndex = pointIndex_1
			      fixedValue = fixedValue_2
			      pointValue = line_1[pointIndex_1][3 - lineDim_1]
			      usedLinePointMask[lineIndex_1][pointIndex_1] = true
			   else
			      lineDim = lineDim_2
			      pointIndex = pointIndex_2
			      fixedValue = fixedValue_1
			      pointValue = line_2[pointIndex_2][3 - lineDim_2]
			      usedLinePointMask[lineIndex_2][pointIndex_2] = true
			   end
			   local point = {}
			   point[lineDim] = fixedValue
			   point[3 - lineDim] = pointValue
			   
			   if pointIndex == 1 then                 
			      if lineDim == 1 then                                 
				 table.insert(points, {point, point, {'point', 3, 4}})                     
			      else                                         
				 table.insert(points, {point, point, {'point', 3, 1}})                                     
			      end                  
			   else                    
			      if lineDim == 1 then                                 
				 table.insert(points, {point, point, {'point', 3, 2}})                     
			      else                                         
				 table.insert(points, {point, point, {'point', 3, 3}})
			      end
			   end
			elseif line_1[1][lineDim_1] < fixedValue_2 and line_1[2][lineDim_1] > fixedValue_2 and line_2[1][lineDim_2] < fixedValue_1 and line_2[2][lineDim_2] > fixedValue_1 then
			   local point = {}
			   point[lineDim_1] = fixedValue_2
			   point[lineDim_2] = fixedValue_1
			   table.insert(points, {point, point, {'point', 4, 1}})
			end
		     end
		  end
	       end
	    end
	 end
      end
      for lineIndex, pointMask in pairs(usedLinePointMask) do
         local lineDim = utils.lineDim(representationGeneral.walls[lineIndex])
         for pointIndex = 1, 2 do
            if pointMask[pointIndex] == false then
               local point = {representationGeneral.walls[lineIndex][pointIndex][1], representationGeneral.walls[lineIndex][pointIndex][2]}
               if pointIndex == 1 then
                  if lineDim == 1 then
                     table.insert(points, {point, point, {'point', 1, 4}})
                  elseif pointIndex == 2 then
		     table.insert(points, {point, point, {'point', 1, 1}})
                  end
               else
                  if lineDim == 1 then
                     table.insert(points, {point, point, {'point', 1, 2}})
                  elseif lineDim == 2 then
		     table.insert(points, {point, point, {'point', 1, 3}})
                  end                
               end
            end
         end
      end
      
      representation.points = points
      representation.doors = representationGeneral.doors              
      representation.icons = representationGeneral.icons
      representation.labels = representationGeneral.labels
   end
   return representation
end

function utils.globalToGrid(width, height, gridWidth, gridHeight, representationGlobal)
   local representation = {}
   for mode, items in pairs(representationGlobal) do   
      representation[mode] = {}   
      for _, item in pairs(items) do   
         local newRectangle = utils.gridRectangle(width, height, gridWidth, gridHeight, item)
	 table.insert(newRectangle, item[3])
	 if newRectangle[1][1] >= 1 and newRectangle[1][1] <= gridWidth and newRectangle[1][2] >= 1 and newRectangle[1][2] <= gridHeight then
	    table.insert(representation[mode], newRectangle)
	 end
      end
   end
   return representation
end

function utils.gridToGlobal(width, height, gridWidth, gridHeight, representation)
   local representationGlobal = {}
   for mode, items in pairs(representation) do   
      representationGlobal[mode] = {}   
      for _, item in pairs(items) do   
         local newRectangle = utils.imageRectangle(width, height, gridWidth, gridHeight, item)
	 table.insert(newRectangle, item[4])
	 
	 --print(mode)             
         --print(item)     
         --print(newRectangle)     

         table.insert(representationGlobal[mode], newRectangle)
      end
   end
   --os.exit(1)
   return representationGlobal
end

function utils.convertRepresentationToTensor(width, height, gridWidth, gridHeight, representationGlobal)
   local representation = utils.globalToGrid(width, height, gridWidth, gridHeight, representationGlobal)

   local offsetsBB = utils.offsetsBB()   
   local offsetsClass = utils.offsetsClass()
   local numFeaturesBB = utils.numFeaturesBB()
   local numFeaturesClass = utils.numFeaturesClass()
   local numItemsPerCell = utils.numItemsPerCell()
   local numFeaturesPerItem = utils.numFeaturesPerItem()

   local representationTensor = torch.zeros(numFeaturesBB + numFeaturesClass, gridHeight, gridWidth)
   local gridItems = {}
   for y = 1, gridHeight do
      gridItems[y] = {}   
      for x = 1, gridWidth do
         gridItems[y][x] = {}
         for mode, offset in pairs(offsetsBB) do
            gridItems[y][x][mode] = {}
         end
      end
   end
   for mode, items in pairs(representation) do
      for __, item in pairs(items) do
         --if gridItems[item[1][2]][item[1][1]][mode] ~= nil then
         table.insert(gridItems[item[1][2]][item[1][1]][mode], item)
         --end
      end
   end

   for x = 1, gridWidth do   
      for y = 1, gridHeight do
         for mode, items in pairs(gridItems[y][x]) do
            local numFeatures = numFeaturesPerItem[mode]
            local sortedItems = {}
            for _, item in pairs(items) do
               table.insert(sortedItems, {item[2][1] + item[2][2], item})
            end
            table.sort(sortedItems, function(a, b) return a[1] < b[1] end)
            for i = numItemsPerCell[mode] + 1, #sortedItems do
               table.remove(sortedItems)
            end
            
            local offsetBB = offsetsBB[mode]
            for itemIndex, item in pairs(sortedItems) do
               item = item[2]
               local itemTensor = representationTensor[{{offsetBB + (itemIndex - 1) * numFeatures + 1, offsetBB + (itemIndex - 1) * numFeatures + numFeatures}, y, x}]
               itemTensor[1] = item[2][1]                                         
               itemTensor[2] = item[2][2]                         
               itemTensor[3] = item[3][1]                                         
               itemTensor[4] = item[3][2]
               itemTensor[5] = 1
            end
            local offsetClass = offsetsClass[mode]
            for itemIndex, item in pairs(sortedItems) do
               item = item[2]
               local class = utils.getNumber(mode, item[4])
	       representationTensor[{offsetClass + itemIndex, y, x}] = class
            end
         end
      end
   end
   return representationTensor
end

function utils.compressRepresentation(width, height, representationTensor)
   local offsetsBB = utils.offsetsBB()      
   local offsetsClass = utils.offsetsClass()   
   local numItemsPerCell = utils.numItemsPerCell()
   local numItemsGlobal = utils.numItemsGlobal()   
   local numFeaturesPerItem = utils.numFeaturesPerItem()
   local numFeaturesBB = utils.numFeaturesBB()
   
   local gridWidth = representationTensor:size(3)
   local gridHeight = representationTensor:size(2)
   local confidenceThreshold = confidenceThreshold or 0.5

   local items = {}
   for x = 1, gridWidth do   
      for y = 1, gridHeight do
         for mode, numItems in pairs(numItemsPerCell) do
	    if mode == 'icons' or mode == 'labels' then
	       local offsetBB = offsetsBB[mode]
	       local offsetClass = offsetsClass[mode]
	       local numFeatures = numFeaturesPerItem[mode]
	       for itemIndex = 1, numItems do
                  local item = representationTensor[{{offsetBB + (itemIndex - 1) * numFeatures + 1, offsetBB + (itemIndex - 1) * numFeatures + numFeatures}, y, x}]
		  
                  if item[5] > confidenceThreshold then
		     local class = representationTensor[{offsetClass + itemIndex, y, x}]                  
		     local name = utils.getItemInfo(mode, class)[1]
		     local newRectangle = utils.gridRectangle(width, height, 1, 1, utils.imageRectangle(width, height, gridWidth, gridHeight, {{x, y}, {item[1], item[2]}, {item[3], item[4]}}))
		     if items[name] == nil then
			items[name] = {}
		     end
		     table.insert(items[name], torch.Tensor({newRectangle[2][1], newRectangle[2][2], newRectangle[3][1], newRectangle[3][2], item[5]}))
		  end
	       end
            end
         end
      end
   end
   local totalNumItems = 0   
   for _, num in pairs(numItemsGlobal) do   
      totalNumItems = totalNumItems + num   
   end   
   local iconLabelTensor = torch.zeros(totalNumItems * 5)
   
   local offset = 0   
   for name, numItems in pairs(numItemsGlobal) do
      if items[name] ~= nil then
	 for itemIndex = 1, math.min(numItems, #items[name]) do
	    iconLabelTensor[{{offset + (itemIndex - 1) * 5 + 1, offset + (itemIndex - 1) * 5 + 5}}] = items[name][itemIndex]
	 end
      end
      offset = offset + numItems * 5
   end
   return {representationTensor[{{1, offsetsBB.icons}}], representationTensor[{{numFeaturesBB, offsetsClass.icons}}], iconLabelTensor:view(-1, 1, 1)}
end

function utils.uncompressRepresentation(width, height, representationTensors)
   local offsetsBB = utils.offsetsBB()      
   local offsetsClass = utils.offsetsClass()   
   local numItemsPerCell = utils.numItemsPerCell()
   local numItemsGlobal = utils.numItemsGlobal()   
   local numFeaturesPerItem = utils.numFeaturesPerItem()
   local numFeaturesBB = utils.numFeaturesBB()
   local numFeaturesClass = utils.numFeaturesClass()
   local modeMap = utils.modeMap()
   
   local gridWidth = representationTensors[1]:size(3)
   local gridHeight = representationTensors[1]:size(2)
   local confidenceThreshold = confidenceThreshold or 0.5

   local iconLabelTensor = representationTensors[3]
   --local iconLabelTensorBB = torch.zeros(numFeaturesBB - offsetsBB.icons, gridHeight, gridWidth)
   --local iconLabelTensorClass = torch.zeros(numFeaturesClass + numFeaturesBB - offsetsClass.icons, gridHeight, gridWidth)
   local representationTensor = torch.zeros(numFeaturesBB + numFeaturesClass, gridHeight, gridWidth)
   representationTensor[{{1, offsetsBB.icons}}] = representationTensors[1]
   representationTensor[{{numFeaturesBB + 1, offsetsClass.icons}}] = representationTensors[2]
   
   local gridItems = {}
   for y = 1, gridHeight do
      gridItems[y] = {}   
      for x = 1, gridWidth do
         gridItems[y][x] = {}
         for mode, offset in pairs(offsetsBB) do
            gridItems[y][x][mode] = {}
         end
      end
   end

   local offset = 0   
   for name, numItems in pairs(numItemsGlobal) do
      local mode = modeMap[name]
      for itemIndex = 1, numItems do
	 local item = iconLabelTensor[{{offset + (itemIndex - 1) * 5 + 1, offset + (itemIndex - 1) * 5 + 5}, 1, 1}]
	 local newRectangle = utils.gridRectangle(width, height, gridWidth, gridWidth, utils.imageRectangle(width, height, 1, 1, {{1, 1}, {item[1], item[2]}, {item[3], item[4]}}))
	 table.insert(newRectangle, {name, 1, 1})
	 --print(item)
	 --print(newRectangle)
	 --print(mode)
	 --print(name)
	 if newRectangle[1][1] >= 1 and newRectangle[1][1] <= gridWidth and newRectangle[1][2] >= 1 and newRectangle[1][2] <= gridHeight then
	    table.insert(gridItems[newRectangle[1][2]][newRectangle[1][1]][mode], {item[5], newRectangle})
	 end
      end
      offset = offset + numItems * 5
   end

   for x = 1, gridWidth do   
      for y = 1, gridHeight do
         for mode, items in pairs(gridItems[y][x]) do
            local numFeatures = numFeaturesPerItem[mode]
            local sortedItems = items
            table.sort(sortedItems, function(a, b) return a[1] > b[1] end)
            for i = numItemsPerCell[mode] + 1, #sortedItems do
               table.remove(sortedItems)
            end
            
            local offsetBB = offsetsBB[mode]
            for itemIndex, item in pairs(sortedItems) do
               item = item[2]
               local itemTensor = representationTensor[{{offsetBB + (itemIndex - 1) * numFeatures + 1, offsetBB + (itemIndex - 1) * numFeatures + numFeatures}, y, x}]
               itemTensor[1] = item[2][1]                                         
               itemTensor[2] = item[2][2]                         
               itemTensor[3] = item[3][1]                                         
               itemTensor[4] = item[3][2]
               itemTensor[5] = 1
            end
            local offsetClass = offsetsClass[mode]
            for itemIndex, item in pairs(sortedItems) do
               item = item[2]
               local class
               if mode == 'icons' then                          
                  class = utils.getNumber(mode, item[4])
               elseif mode == 'labels' then                         
                  class = utils.getNumber(mode, item[4])
               end
               representationTensor[{offsetClass + itemIndex, y, x}] = class
            end
         end
      end
   end

   return representationTensor
end


function utils.convertTensorToRepresentation(width, height, representationTensor, confidenceThreshold)
   local offsetsBB = utils.offsetsBB()      
   local offsetsClass = utils.offsetsClass()   
   local numItemsPerCell = utils.numItemsPerCell()   
   local numFeaturesPerItem = utils.numFeaturesPerItem()
   
   local representation = {}
   representation.points = {}
   representation.doors = {}
   representation.icons = {}
   representation.labels = {}
   
   local gridWidth = representationTensor:size(3)
   local gridHeight = representationTensor:size(2)
   local confidenceThreshold = confidenceThreshold or 0.5

   for x = 1, gridWidth do   
      for y = 1, gridHeight do
         for mode, numItems in pairs(numItemsPerCell) do
            local offsetBB = offsetsBB[mode]
            local offsetClass = offsetsClass[mode]
            local numFeatures = numFeaturesPerItem[mode]
            for itemIndex = 1, numItems do
               local item = representationTensor[{{offsetBB + (itemIndex - 1) * numFeatures + 1, offsetBB + (itemIndex - 1) * numFeatures + numFeatures}, y, x}]
               local class = representationTensor[{offsetClass + itemIndex, y, x}]
               
               if item[5] > confidenceThreshold then
		  table.insert(representation[mode], {{x, y}, {item[1], item[2]}, {item[3], item[4]}, utils.getItemInfo(mode, class)})
               end
            end
         end
      end
   end

   local representationGlobal = utils.gridToGlobal(width, height, gridWidth, gridHeight, representation)
   return representationGlobal
end

function utils.cropRepresentation(representation, startX, startY, endX, endY)
   local newRepresentation = {}
   for mode, items in pairs(representation) do
      newRepresentation[mode] = {}
      for _, item in pairs(items) do
         if (item[1][1] + item[2][1]) / 2 <= endX and (item[1][2] + item[2][2]) / 2 <= endY then
            for pointIndex = 1, 2 do
               item[pointIndex][1] = item[pointIndex][1] - startX
               item[pointIndex][2] = item[pointIndex][2] - startY
            end
            table.insert(newRepresentation[mode], item)
         end
      end
   end
   return newRepresentation
end

function utils.scaleRepresentation(representation, width, height, newWidth, newHeight)
   local newRepresentation = {}
   for mode, items in pairs(representation) do
      newRepresentation[mode] = {}
      for _, item in pairs(items) do
         for pointIndex = 1, 2 do
            item[pointIndex][1] = torch.round((item[pointIndex][1] - 1) / (width - 1) * (newWidth - 1) + 1)
            item[pointIndex][2] = torch.round((item[pointIndex][2] - 1) / (height - 1) * (newHeight - 1) + 1)
         end
         table.insert(newRepresentation[mode], item)
      end
   end
   return newRepresentation
end

function utils.scaleRepresentationByRatio(representation, ratio)
   local newRepresentation = {}
   for mode, items in pairs(representation) do
      newRepresentation[mode] = {}
      for _, item in pairs(items) do
         for pointIndex = 1, 2 do
            item[pointIndex][1] = torch.round((item[pointIndex][1] - 1) * ratio + 1)
            item[pointIndex][2] = torch.round((item[pointIndex][2] - 1) * ratio + 1)
         end
         table.insert(newRepresentation[mode], item)
      end
   end
   return newRepresentation
end

function utils.rotateRepresentation(representation, width, height, orientation)
   --[[
   if orientation == 1 then      
      return representation
   end
   ]]--
   
   local newRepresentation = {}
   for mode, items in pairs(representation) do   
      newRepresentation[mode] = {}
      for _, item in pairs(items) do
	 for pointIndex = 1, 2 do
            local x = item[pointIndex][1]              
            local y = item[pointIndex][2]
            if orientation == 2 then
               item[pointIndex][1] = height - y                
               item[pointIndex][2] = x
            elseif orientation == 3 then
               item[pointIndex][1] = width - x                                 
               item[pointIndex][2] = height - y
            else
               item[pointIndex][1] = y                                 
               item[pointIndex][2] = width - x
            end
         end
	 if mode == 'icons' or mode == 'labels' then
	    item = {{math.min(item[1][1], item[2][1]), math.min(item[1][2], item[2][2])}, {math.max(item[1][1], item[2][1]), math.max(item[1][2], item[2][2])}, item[3]}
	 end
         table.insert(newRepresentation[mode], item)
      end
   end
   newRepresentation.walls = utils.sortLines(newRepresentation.walls)
   newRepresentation.doors = utils.sortLines(newRepresentation.doors)
   return newRepresentation
end

function utils.drawRepresentationImage(width, height, gridWidth, gridHeight, floorplan, representation, representationType, renderingType, lineWidth)
   local iconImages = utils.loadIconImages()
   
   local representationType = representationType or 'P'
   local renderingType = renderingType or 'P'
   local lineWidth = lineWidth or 5

   local colorMap = {}
   colorMap[1] = {255, 0, 0}   
   colorMap[2] = {0, 255, 0}   
   colorMap[3] = {0, 0, 255}
   colorMap[4] = {255, 255, 0}      
   colorMap[5] = {0, 255, 255}      
   colorMap[6] = {255, 0, 255}
   colorMap[7] = {128, 0, 0}
   colorMap[8] = {0, 128, 0}      
   colorMap[9] = {0, 0, 128}

   if representationType == 'P' and renderingType == 'P' then
      local representationImage = floorplan
      for mode, items in pairs(representation) do
	 if mode == 'points' or mode == 'doors' or mode == 'icons' or mode == 'labels' then   
	    for __, item in pairs(items) do   
	       local rectangle = {item[1], item[2]}
               local center = {(rectangle[2][1] + rectangle[1][1]) / 2, (rectangle[2][2] + rectangle[1][2]) / 2}   
	       local rectangleWidth = math.max(rectangle[2][1] - rectangle[1][1] + 1, 10)   
	       local rectangleHeight = math.max(rectangle[2][2] - rectangle[1][2] + 1, 10)   
	       local color = colorMap[item[3][2]]   
	       
	       local strokeWidth = 2
	       if mode == 'points' then   
		  strokeWidth = 10   
	       end

	       local success, newRepresentationImage = pcall(function() return image.drawRect(representationImage, math.max(center[1] - rectangleWidth / 2, 1), math.max(center[2] - rectangleHeight / 2, 1), math.min(center[1] + rectangleWidth / 2, width), math.min(center[2] + rectangleHeight / 2, height), {lineWidth = strokeWidth, color = color}) end)
	       if success then
		  representationImage = newRepresentationImage
	       end
	    end   
	 end   
      end
      return representationImage
   elseif representationType == 'P' and renderingType == 'L' then
      local representationImage = torch.ones(#floorplan)

      local lines = utils.pointsToLines(width, height, representation.points, lineWidth)
      local lineMask = utils.drawLineMask(width, height, lines, lineWidth)

      for c = 1, 3 do
	 representationImage[c][lineMask:byte()] = 0
      end
      
      for mode, items in pairs(representation) do
	 if mode == 'doors' then
	    local doorWidth = 3
            for _, line in pairs(items) do
               local lineDim = utils.lineDim(line)
               if lineDim > 0 then
                  local maxSize = {width, height}
                  local rectangle = {{}, {}}
                  rectangle[1][lineDim] = math.min(line[1][lineDim], line[2][lineDim])            
                  rectangle[2][lineDim] = math.max(line[1][lineDim], line[2][lineDim])
                  rectangle[1][3 - lineDim] = math.max((line[1][3 - lineDim] + line[2][3 - lineDim]) / 2 - doorWidth, 1)
                  rectangle[2][3 - lineDim] = math.min((line[1][3 - lineDim] + line[2][3 - lineDim]) / 2 + doorWidth, maxSize[3 - lineDim])
                  
                  representationImage[{{}, {rectangle[1][2], rectangle[2][2]}, {rectangle[1][1], rectangle[2][1]}}] = 1
                  --success, newRepresentationImage = pcall(function() return image.drawRect(representationImage, rectangle[1][1], rectangle[1][2], rectangle[2][1], rectangle[2][2], {lineWidth = lineWidth, color = {0, 0, 0}}) end)
                  --if success then               
                  --representationImage = newRepresentationImage               
                  --end
               end
               --representationImage[{{}, {minX, maxX}, {minY, maxY}}] = 0
            end            
         elseif mode == 'icons' or mode == 'labels' then
            for __, item in pairs(items) do
	       --print(item)
	       local iconImage = iconImages[item[3][1]][item[3][2]]
               --local rectangle = {item[1], item[2]}
	       local rectangle = {{math.min(item[1][1], item[2][1]), math.min(item[1][2], item[2][2])}, {math.max(item[1][1], item[2][1]), math.max(item[1][2], item[2][2])}}
	       for pointIndex = 1, 2 do
		  rectangle[pointIndex][1] = math.max(math.min(rectangle[pointIndex][1], width), 1)
		  rectangle[pointIndex][2] = math.max(math.min(rectangle[pointIndex][2], height), 1)
	       end
               --print(mode)
               --print(rectangle)
	       local orientation = 1
	       if mode == 'icons' then
		  if math.abs(rectangle[2][1] - rectangle[1][1]) > math.abs(rectangle[2][2] - rectangle[1][2]) and item[3][1] ~= 'toilet' then
		     local min = math.min(rectangle[1][2], rectangle[2][2])
		     local max = math.max(rectangle[1][2], rectangle[2][2])
		     local center = (rectangle[1][1] + rectangle[2][1]) / 2
		     local deltaMin = 0
		     for delta = 1, min - 1 do
			deltaMin = delta
                	if lineMask[min - delta][center] == 1 then
			   break             
			end                  
		     end
		     local deltaMax = 0
		     for delta = 1, height - max do
			deltaMax = delta
			if lineMask[max + delta][center] == 1 then
			   break
			end
		     end
		     if deltaMin > deltaMax then
			orientation = 1
		     else
			orientation = 3
		     end
		  else
		     local min = math.min(rectangle[1][1], rectangle[2][1])
		     local max = math.max(rectangle[1][1], rectangle[2][1])
		     local center = (rectangle[1][2] + rectangle[2][2]) / 2
		     local deltaMin = 0
		     for delta = 1, min - 1 do
			deltaMin = delta
                	if lineMask[center][min - delta] == 1 then
			   break
			end
		     end
		     local deltaMax = 0
		     for delta = 1, height - max do
			deltaMax = delta
			if lineMask[center][max + delta] == 1 then
			   break
			end
		     end
		     if deltaMin > deltaMax then
			orientation = 4
		     else
			orientation = 2
		     end
		  end
	       end

	       if iconImage == nil then
		  print(item)
	       end

               iconImage = rotateIcon(iconImage, orientation)

               local icon = image.scale(iconImage, rectangle[2][1] - rectangle[1][1] + 1, rectangle[2][2] - rectangle[1][2] + 1)
               if icon:dim() == 2 or icon:size(1) == 1 then
		  icon = icon:repeatTensor(3, 1, 1)
	       end

	       --print(item)
	       --print(#icon)
               --print(#representationImage[{{}, {rectangle[1][2], rectangle[2][2]}, {rectangle[1][1], rectangle[2][1]}}])
	       representationImage[{{}, {rectangle[1][2], rectangle[2][2]}, {rectangle[1][1], rectangle[2][1]}}] = icon
            end   
         end   
      end
      return representationImage      
   end
end


function utils.loadRepresentation(filename)
   local representationExists, representationInfo = pcall(function()   
         return csvigo.load({path=filename, mode="large", header=false, separator='\t', verbose=false})   
   end)
   if representationExists and representationInfo ~= nil then
      local representation = {}
      representation.walls = {}
      representation.doors = {}      
      representation.icons = {}      
      representation.labels = {}
      local modeMap = utils.modeMap()
      for _, item in pairs(representationInfo) do
         local itemMode = modeMap[item[5]]
         local itemInfo = {{tonumber(item[1]), tonumber(item[2])}, {tonumber(item[3]), tonumber(item[4])}, {item[5], tonumber(item[6]), tonumber(item[7])}}
	 --print(item[5])
	 --print(itemMode)
         table.insert(representation[itemMode], itemInfo)
      end
      return representation   
   else
      return nil
   end
end

function utils.finalizeRepresentation(representation)
   representation.walls = utils.stitchLines(utils.sortLines(representation.walls), 5)
   representation.doors = utils.fixedDoors(utils.sortLines(representation.doors), representation.walls, 5)
   return representation
end

function utils.saveRepresentation(filename, representation, ratio)
   --local representationExists, representationFile = pcall(function()      
   --return io.open(filename, 'r')
   --end)
   --local override = false
   --if representationExists then      
   --end
   print('save representation')
   
   representation = utils.finalizeRepresentation(representation)

   if ratio ~= nil and ratio ~= 1 then
      representation = utils.scaleRepresentationByRatio(representation, ratio)
   end
   
   pl.dir.makepath(filename:match('(.+)/(.+)'))
   local representationFile = io.open(filename, 'w')
   for itemMode, items in pairs(representation) do
      for _, item in pairs(items) do
         for __, field in pairs(item) do
            if __ <= 3 then
               for ___, value in pairs(field) do
                  representationFile:write(value .. '\t')
               end
            end
         end
         representationFile:write('\n')
      end
   end
   
   representationFile:close()
end

function utils.printRepresentation(representation)
   for itemMode, items in pairs(representation) do
      for _, item in pairs(items) do
         --for __, field in pairs(item) do
	 --if __ <= 3 then
	 --for ___, value in pairs(field) do
	 --end
   --end
	 --end
	 print('(' .. item[1][1] .. ', ' .. item[1][2] .. ')\t(' .. item[2][1] .. ', ' .. item[2][2] .. ')\t' .. item[3][1] .. ' ' .. item[3][2] .. ' ' .. item[3][3])
         print('\n')
      end
   end
end

function utils.predictRepresentation(floorplan)
   if utils.model == nil then
      utils.model = torch.load('/home/chenliu/Projects/Floorplan/models/representation-segmentation-floorplan-representation/model_best.t7')
      --utils.model = torch.load('/home/chenliu/Projects/Floorplan/models/yolo-floorplan-representation/model_best.t7')
   end

   local width = floorplan:size(3)
   local height = floorplan:size(2)
   local sampleDim = 256
   --local floorplanScaled = image.scale(floorplan, sampleDim, sampleDim)
   local lineWidth = lineWidth or 5
   
   local model = utils.model
   model:evaluate()

   package.path = '../InverseCAD/datasets/?.lua;' .. package.path   
   package.path = '../InverseCAD/?.lua;' .. package.path   
   --local dataset = require('/home/chenliu/Projects/Floorplan/floorplan/InverseCAD/datasets/floorplan-representation')(nil, nil, 'val')   
   --local dataset = require('floorplan-representation')(nil, nil, 'val')   
   --local dataset = require 'floorplan-representation'({}, nil, 'val')   
   
   local dataset = require('floorplan-representation')   
   local floorplanNormalized = dataset:preprocessBoth(sampleDim, sampleDim)(floorplan)   
   local input = floorplanNormalized:repeatTensor(1, 1, 1, 1):cuda()
   --local input = floorplanScaled:repeatTensor(1, 1, 1, 1):cuda()

   local output = model.modules[1]:forward(input)
   local prob, pred = torch.max(output[2]:double(), 2)
   pred = pred[{{}, 1}]:view(-1, 8, 8, 8):transpose(3, 4):transpose(2, 3):double()
   local outputRepresentation = torch.cat(output[1]:double(), pred, 2)
   --[[
      local floorplan = self.input[batchIndex]:double()
            image.save(self.opt.tmp .. '/floorplan_' .. checkedResultIndex .. '.png', floorplan)
      local representationTensor = self.representationInput[batchIndex]                       
            local representationPreview = rep_ut.convertTensorToRepresentation(self.opt.sampleDim, self.opt.sampleDim, representationTensor, 0.5)                   
      local representationImage = rep_ut.drawRepresentationImage(self.opt.sampleDim, self.opt.sampleDim, self.opt.gridDim, self.opt.gridDim, floorplan, representationPreview)
      image.save(self.opt.tmp .. '/target_' .. checkedResultIndex .. '.png', representationImage)
      local representationPreview = rep_ut.convertTensorToRepresentation(self.opt.sampleDim, self.opt.sampleDim, representationTensor, 0.5)              
      local representationImage = rep_ut.drawRepresentationImage(self.opt.sampleDim, self.opt.sampleDim, self.opt.gridDim, self.opt.gridDim, floorplan, representationPreview)   
      image.save(self.opt.tmp .. '/prediction_' .. checkedResultIndex .. '.png', representationImage)   
      checkedResultIndex = checkedResultIndex + 1
   ]]--
   local representationTensor = outputRepresentation[1]
   local representation = utils.convertTensorToRepresentation(sampleDim, sampleDim, representationTensor, 0.5)
   local representationUnscaled = utils.scaleRepresentation(representation, sampleDim, sampleDim, width, height)
   local representationGeneral = utils.convertRepresentationToGeneral(width, height, representationUnscaled, 'P', lineWidth)
   return representationGeneral
end

--[[
   lines = {}
   table.insert(lines, {{1, 1}, {1, 10}})
   table.insert(lines, {{1, 11}, {20, 11}})
   print(lines)
   print(stitchLines(lines, 5))
]]--

function utils.predictSegmentation(floorplan)
   if utils.model == nil then
      utils.model = torch.load('/home/chenliu/Projects/Floorplan/models/segmentation-floorplan-representation/model_best.t7')
   end

   local width = floorplan:size(3)
   local height = floorplan:size(2)
   local sampleDim = 256
   --local floorplanScaled = image.scale(floorplan, sampleDim, sampleDim)
   local lineWidth = lineWidth or 5
   
   local model = utils.model
   --model:evaluate()

   --local datasets = require 'datasets/init'
   --local opts = require '../../InverseCAD/opts'
   --local opt = opts.parse(arg)
   package.path = '../InverseCAD/datasets/?.lua;' .. package.path   
   package.path = '../InverseCAD/?.lua;' .. package.path   
   --local dataset = require('/home/chenliu/Projects/Floorplan/floorplan/InverseCAD/datasets/floorplan-representation')(nil, nil, 'val')   
   --local dataset = require('floorplan-representation')(nil, nil, 'val')   
   --local dataset = require 'floorplan-representation'({}, nil, 'val')   
   
   local dataset = require('floorplan-representation')   
   local floorplanNormalized = dataset:preprocessBoth(sampleDim, sampleDim)(floorplan)   
   local input = floorplanNormalized:repeatTensor(1, 1, 1, 1):cuda()

   --print(#input)
   local output = model:forward(input)
   --print(output[1])
   local prob, pred = torch.max(output:double(), 2)
   local prediction = pred[{{}, 1}]:view((#input)[1], sampleDim, sampleDim)[1]:double()
   local segmentationImage = fp_ut.drawSegmentation(prediction, torch.max(prediction))
   segmentationImage = image.scale(segmentationImage, width, height)
   return segmentationImage
end



function utils.segmentFloorplan(floorplan, binaryThreshold, numOpenOperations, reverse, considerEdge)

   --local floorplanBinary = torch.ones((#floorplan)[2], (#floorplan)[3])
   --for c = 1, 3 do
   --local mask = floorplan[c]:lt(binaryThreshold):double()
   --floorplanBinary = torch.cmul(floorplanBinary, mask)
   --end
   local floorplanBinary = floorplan:max(1)[1]:lt(binaryThreshold):double()

   if considerEdge then
      local floorplanGray = floorplan:mean(1)[1]
      local horizontalKernel = torch.zeros(3, 3)
      local verticalKernel = torch.zeros(3, 3)
      for c = 1, 3 do
	 horizontalKernel[{2, c}] = 1    
         horizontalKernel[{1, c}] = -0.5         
         horizontalKernel[{3, c}] = -0.5
         verticalKernel[{c, 2}] = 1    
         verticalKernel[{c, 1}] = -0.5
         verticalKernel[{c, 3}] = -0.5
      end
      local horizontalEdgeMap = image.convolve(floorplanGray, horizontalKernel, 'same'):lt(-0.1):double()
      local verticalEdgeMap = image.convolve(floorplanGray, verticalKernel, 'same'):lt(-0.1):double()
	 --horizontalEdgeMap = image.erode(image.dilate(horizontalEdgeMap))
      --verticalEdgeMap = image.erode(image.dilate(verticalEdgeMap))
      --image.save('test/edge_1.png', horizontalEdgeMap)
      --image.save('test/edge_2.png', verticalEdgeMap)
      floorplanBinary = (floorplanBinary + horizontalEdgeMap + verticalEdgeMap):gt(0):double()
   end
   --floorplanBinary = image.dilate(floorplanBinary)
   
   local kernel = torch.ones(3, 3)
   if numOpenOperations > 0 then   
      for i = 1, numOpenOperations do   
         floorplanBinary = image.erode(floorplanBinary)
         floorplanBinary = image.dilate(floorplanBinary)
      end   
   elseif numOpenOperations < 0 then   
      for i = 1, -numOpenOperations do
         floorplanBinary = image.dilate(floorplanBinary)
         floorplanBinary = image.erode(floorplanBinary)
      end   
   end

   floorplanBinaryByte = (floorplanBinary * 255):byte()   
   if reverse ~= nil and reverse then   
      floorplanBinaryByte = 255 - floorplanBinaryByte   
   end   
   local floorplanComponent = torch.IntTensor(floorplanBinaryByte:size())      
   local numComponents = cv.connectedComponents{255 - floorplanBinaryByte, floorplanComponent}
   floorplanComponent = floorplanComponent + 1
   return floorplanComponent, numComponents, floorplanBinary
end


function utils.findWalls(floorplan, denotedWalls, lineWidth, lineLength)
   local width = floorplan:size(3)   
   local height = floorplan:size(2)
   
   local lineWidth = lineWidth or 5
   local binaryThreshold = 0.7
   local minLength = lineWidth * 2 or 10
   if denotedWalls == nil then
      local floorplanSegmentationReversed, numSegmentsReversed, floorplanBinaryReversed = utils.segmentFloorplan(floorplan, binaryThreshold, 0, true)
      local backgroundSegmentReversed = floorplanSegmentationReversed[1][1]
      local maxCount = 0
      local borderSegmentReversed
      for segmentReversed = 1, numSegmentsReversed do
         if segmentReversed ~= backgroundSegmentReversed then
            local indices = floorplanSegmentationReversed:eq(segmentReversed):nonzero()      
            if ##indices > 0 then
               local count = (#indices)[1]
               if count > maxCount then
                  borderSegmentReversed = segmentReversed
                  maxCount = count
               end
            end
         end
      end
      if borderSegmentReversed then
	 local borderMask = floorplanSegmentationReversed:eq(borderSegmentReversed)
         binaryThreshold = torch.max(floorplan, 1)[1][borderMask]:max()
      end
   else
      local denotedWallMask = torch.zeros(height, width)
      for _, wall in pairs(denotedWalls) do
	 local mins = {}
	 local maxs = {}
	 for c = 1, 2 do
	    mins[c] = math.min(wall[1][c], wall[2][c])
	    maxs[c] = math.max(wall[1][c], wall[2][c])
	 end
	 denotedWallMask[{{mins[2], max[2]}, {mins[1], max[1]}}] = 1
      end
      binaryThreshold = torch.max(floorplan, 1)[1][denotedWallMask]:mean() + 0.1
   end
   local floorplanSegmentation, numSegments, floorplanBinary = utils.segmentFloorplan(floorplan, binaryThreshold, 0)
   local floorplanSegmentationReversed, numSegmentsReversed, floorplanBinaryReversed = utils.segmentFloorplan(floorplan, binaryThreshold, 0, true)
   --[[
      local backgroundSegmentReversed = floorplanSegmentationReversed[1][1]
   if partialWallMask ~= nil then
      floorplanSegmentationReversed = torch.cmul(floorplanSegmentationReversed, partialWallMask)
   end
   local maxCount = 0
   local borderSegmentReversed
   for segmentReversed = 1, numSegmentsReversed do
      if segmentReversed ~= backgroundSegmentReversed then
         local indices = floorplanSegmentationReversed:eq(segmentReversed):nonzero()      
         if ##indices > 0 then
            local count = (#indices)[1]
            if count > maxCount then
               borderSegmentReversed = segmentReversed
               maxCount = count
            end
         end
      end
   end
   if borderSegmentReversed == nil then
      return torch.zeros(#floorplan)
      end
      local borderMask = floorplanSegmentationReversed:eq(borderSegmentReversed)
   ]]--      
   --local borderMask = floorplanSegmentationReversed:gt(1)
   local borderMask = floorplanSegmentation:eq(1)
   --[[
   local doorWidth = 5
   for i = 1, doorWidth do
      borderMask = image.dilate(borderMask)
   end
   for i = 1, doorWidth do
      borderMask = image.erode(borderMask)
   end
   ]]--
   local lineLengthMask = torch.zeros(4, height, width)
   for x = 1, width do
      local length = 0
      for y = 1, height do
	 if borderMask[y][x] == 1 then
	    length = length + 1
	    lineLengthMask[1][y][x] = length
         else
	    length = 0
	 end
      end
      length = 0
      for y = height, 1, -1 do
         if borderMask[y][x] == 1 then
            length = length + 1
            lineLengthMask[3][y][x] = length
         else
            length = 0
         end
      end
   end
   for y = 1, height do
      local length = 0
      for x = 1, width do   
         if borderMask[y][x] == 1 then   
            length = length + 1   
            lineLengthMask[4][y][x] = length   
         else   
            length = 0   
         end   
      end   
      length = 0
      for x = width, 1, -1 do   
         if borderMask[y][x] == 1 then   
            length = length + 1   
            lineLengthMask[2][y][x] = length   
         else   
            length = 0   
         end   
      end   
   end
   local minLineWidth = 5   
   local maxLineWidth = 15   
   local minLineLength = 20
   
   local horizontalLineLengthMask = lineLengthMask[2] + lineLengthMask[4] - 1
   local verticalLineLengthMask = lineLengthMask[1] + lineLengthMask[3] - 1
   local lineTypeMask = torch.zeros(height, width)
   lineTypeMask[torch.cmul(torch.cmul(verticalLineLengthMask:ge(minLineWidth), verticalLineLengthMask:le(maxLineWidth)), horizontalLineLengthMask:ge(minLineLength))] = 1
   lineTypeMask[torch.cmul(torch.cmul(horizontalLineLengthMask:ge(minLineWidth), horizontalLineLengthMask:le(maxLineWidth)), verticalLineLengthMask:ge(minLineLength))] = 2


   --local minLineWidth = 5 
   local maxDoorWidth = 8
   local minDoorLength = 15
   local backgroundSegment = floorplanSegmentation[1][1]
   for segment = 2, numSegments do
      if segment ~= backgroundSegment then
	 local mask = floorplanSegmentation:eq(segment)
	 local indices = floorplanSegmentation:eq(segment):nonzero()
	 if ##indices > 0 then
	    local mins = torch.min(indices, 1)[1]
	    local maxs = torch.max(indices, 1)[1]
	    for c = 1, 2 do
	       if maxs[c] - mins[c] <= maxDoorWidth and maxs[3 - c] - mins[3 - c] >= minDoorLength then
		  lineTypeMask[mask] = c
		  borderMask[mask] = 1
	       end
	    end
	 end
      end
   end

   local width = floorplan:size(3)
   local height = floorplan:size(2)
   local pointLineTypeMask = torch.zeros(4, height, width)
   for x = 1, width do
      local lineExists = false
      for y = 1, height do
         if lineTypeMask[y][x] == 2 then
	    lineExists = true
         end
	 if borderMask[y][x] == 1 then
	    if lineExists then
	       pointLineTypeMask[1][y][x] = 1
	    end
	 else
	    lineExists = false
         end
      end
      lineExists = false
      for y = height, 1, -1 do
         if lineTypeMask[y][x] == 2 then
            lineExists = true
         end
         if borderMask[y][x] == 1 then
            if lineExists then
               pointLineTypeMask[3][y][x] = 1
            end
         else
            lineExists = false
         end
      end
   end
   for y = 1, height do
      local lineExists = false
      for x = 1, width do
         if lineTypeMask[y][x] == 1 then
            lineExists = true
         end
         if borderMask[y][x] == 1 then
            if lineExists then
               pointLineTypeMask[4][y][x] = 1
            end
         else
            lineExists = false
         end
      end
      lineExists = false
      for x = width, 1, -1 do
         if lineTypeMask[y][x] == 1 then
            lineExists = true
         end
         if borderMask[y][x] == 1 then
            if lineExists then
               pointLineTypeMask[2][y][x] = 1
            end
         else
            lineExists = false
         end
      end
   end

   local pointMask = torch.cmul(pointLineTypeMask[1] + pointLineTypeMask[3], pointLineTypeMask[2] + pointLineTypeMask[4]):gt(0)
   pointMask = image.erode(pointMask)
   pointMask = image.dilate(pointMask)
   pointMask = image.dilate(pointMask)
   
   local pointIndexedMask, numPoints = utils.findConnectedComponents(pointMask)
   local points = {}
   for pointIndex = 1, numPoints do
      local indices = pointIndexedMask:eq(pointIndex):nonzero()
      if ##indices > 0 then
         local means = torch.mean(indices:double(), 1)[1]
	 local x = torch.round(means[2])
	 local y = torch.round(means[1])
	 local lineTypes = pointLineTypeMask[{{}, y, x}]
	 
	 local pointType = lineTypes:sum()
	 local pointOrientation
	 if pointType == 2 then
	    if lineTypes[1] == 1 then
	       if lineTypes[2] == 1 then               
                  pointOrientation = 2
               elseif lineTypes[4] == 1 then           
                  pointOrientation = 1
               end
            elseif lineTypes[3] == 1 then
	       if lineTypes[2] == 1 then               
                  pointOrientation = 3
               elseif lineTypes[4] == 1 then
                  pointOrientation = 4
               end
            end
	 elseif pointType == 3 then
            for c = 1, 4 do
	       if lineTypes[c] == 0 then
		  pointOrientation = c
	       end
	    end
	 elseif pointType == 4 then
	    pointOrientation = 1
         end
	 if pointOrientation then
	    table.insert(points, {{x, y}, {x, y}, {'point', pointType, pointOrientation}})
	    --print('(' .. x .. ', ' .. y .. ')\t' .. pointType .. ' ' .. pointOrientation)
	 end
      end
   end

   local walls = utils.pointsToLines(width, height, points, lineWidth)
   return walls, floorplanSegmentation
end

function utils.findDoors(floorplan, denotedDoors, walls, floorplanSegmentation)
end

function utils.extractRepresentation(floorplan, denotedRepresentation, modes)
   local representation = {}
   local denotedRepresentation = denotedRepresentation or {}
   
   representation.walls, floorplanSegmentation = utils.findWalls(floorplan, denotedRepresentation.walls, 5)
   --representation.doors = utils.findDoors(floorplan, denotedRepresentation.doors, representation.walls, floorplanSegmentation)
   representation.doors = {}
   representation.icons = {}
   representation.labels = {}
   return representation, floorplanSegmentation
end

function utils.extractCandidateRegions(floorplan, floorplanSegmentation, walls, lineWidth)
   local width = floorplan:size(3)
   local height = floorplan:size(2)
   
   local candidateRegions = {}
   candidateRegions.doors = {}
   candidateRegions.icons = {}
   --candidateRegions.labels = {}

   local lineWidth = lineWidth or 5
   
   local lineMask = utils.drawLineMask(width, height, walls, lineWidth)   
   if floorplanSegmentation == nil then
      local binaryThreshold = torch.max(floorplan, 1)[1][lineMask:byte()]:mean() + 0.1
      floorplanSegmentation, numSegments, floorplanBinary = utils.segmentFloorplan(floorplan, binaryThreshold, 0, false, true)
   end   

   local doorMask = torch.cmul(floorplanSegmentation:gt(1):double(), image.dilate(lineMask))
   for segment = 2, torch.max(floorplanSegmentation) do   
      local segmentMask = floorplanSegmentation:eq(segment)   
      local indices = doorMask[segmentMask]:nonzero()   
      if ##indices > 0 then   
         if (#indices)[1] < (#segmentMask:nonzero())[1] then   
            doorMask[segmentMask] = 0   
         end   
      end   
   end
   doorMask = image.dilate(doorMask)
   local doors, numDoors = utils.findConnectedComponents(doorMask)
   local wallMask = utils.drawLineMask(width, height, walls, lineWidth, true)
   local doorIndex = 1
   while doorIndex <= numDoors do
      local door = doors:eq(doorIndex)
      local indices = door:nonzero()
      if ##indices > 0 then
	 local wallIndex = wallMask[indices[1]:totable()]
	 local notInWall = wallMask:ne(wallIndex)
	 local doorNotInWall = torch.cmul(door, notInWall)
	 if ##doorNotInWall:nonzero() > 0 then
	    numDoors = numDoors + 1
	    doors[doorNotInWall] = numDoors
	 end
      end
      doorIndex = doorIndex + 1
   end

   floorplanSegmentation = torch.cmul(floorplanSegmentation, (1 - lineMask):int())
   local smallSegments = {}
   for segment = 2, torch.max(floorplanSegmentation) do   
      local segmentMask = floorplanSegmentation:eq(segment)   
      local indices = segmentMask:nonzero()
      if ##indices > 0 then
	 local mins = torch.min(indices, 1)[1]   
         local maxs = torch.max(indices, 1)[1]
         if (#indices)[1] < width * height * 0.03 and maxs[1] - mins[1] < height * 0.25 and maxs[2] - mins[2] < width * 0.25 then
	    table.insert(smallSegments, segmentMask)
         end
      end
   end
   local rooms, numRooms = utils.findConnectedComponents(1 - lineMask)      
   local backgroundRoomIndex = rooms[1][1]

   local iconMask = torch.zeros(height, width)
   for roomIndex = 1, numRooms do
      if roomIndex ~= backgroundRoomIndex then
	 local roomMask = rooms:eq(roomIndex)
	 --local maxCount
	 --local maxCountSegmentIndex
	 if ##roomMask:nonzero() > 0 then
	    local roomCount = (#roomMask:nonzero())[1]
	    local iconSegments = {}
	    for segmentIndex, segmentMask in pairs(smallSegments) do
	       local indices = torch.cmul(segmentMask, roomMask):nonzero()
	       if ##indices > 0 then
		  local count = (#indices)[1]
		  if count == (#segmentMask:nonzero())[1] and count < roomCount * 0.5 then
		     table.insert(iconSegments, segmentIndex)
		  end
	       end
	    end
	    --table.insert(invalidSegments, maxCountSegmentIndex)
	    for _, segmentIndex in pairs(iconSegments) do
	       local indices = smallSegments[segmentIndex]:nonzero()
	       local mins = torch.min(indices, 1)[1]        
	       local maxs = torch.max(indices, 1)[1]
	       --local segmentMask = torch.zeros(height, width)
	       --segmentMask[{{mins[1], maxs[1]}, {mins[2], maxs[2]}}] = 1
	       --iconMask[torch.cmul(segmentMask:byte(), roomMask)] = 0
	       iconMask[{{mins[1], maxs[1]}, {mins[2], maxs[2]}}] = 1
	    end
	 end
      end
   end

   --image.save('test/mask_1.png', iconMask:double())
   iconMask = image.dilate(iconMask)
   local icons, numIcons = utils.findConnectedComponents(iconMask)

   --image.save('test/binary.png', floorplanBinary:double())
   image.save('test/floorplan.png', floorplan)
   image.save('test/segmentation.png', utils.drawSegmentation(floorplanSegmentation, torch.max(floorplanSegmentation)))
   image.save('test/mask.png', iconMask:double())
   --image.save('test/mask.png', (1 - torch.cmul(doors:eq(0), icons:eq(0))):double())
   --os.exit(1)
      --[[
	 if true then
	 return 1 - torch.cmul(doors:eq(0), icons:eq(0))
         end
      ]]--
   local candidateRegions = {}
   candidateRegions.doors = doors
   candidateRegions.icons = icons
   --return candidateRegions, torch.clamp(floorplan * 0.2 + torch.cat(torch.cat(doors:eq(0):repeatTensor(1, 1, 1):double(), icons:eq(0):repeatTensor(1, 1, 1):double(), 1), torch.ones(1, height, width), 1), 0, 1)
   return candidateRegions, torch.cat(torch.cat(doors:eq(0):repeatTensor(1, 1, 1):double(), icons:eq(0):repeatTensor(1, 1, 1):double(), 1), torch.ones(1, height, width), 1)
end

function utils.getFloorplanSegmentation(width, height, representation, lineWidth)
   local lineWidth = lineWidth or 5   
   local lineMask = utils.drawLineMask(width, height, representation.walls, lineWidth)
   local rooms, numRooms = utils.findConnectedComponents(1 - lineMask)      
   local backgroundRoomIndex = rooms[1][1]
   local floorplanSegmentation = torch.zeros(#rooms)
   for _, label in pairs(representation.labels) do   
      local center = {torch.round((label[1][1] + label[2][1]) / 2), torch.round((label[1][2] + label[2][2]) / 2)}
      local number = utils.getNumber('labels', label[3])
      local roomIndex = rooms[{center[2], center[1]}]
      if roomIndex > 0 and roomIndex ~= backgroundRoomIndex then
	 local segmentIndex = floorplanSegmentation[{center[2], center[1]}]
	 if segmentIndex == 0 or (number < segmentIndex and segmentIndex ~= 3) or (number == 2 and segmentIndex == 3) then
	    floorplanSegmentation[rooms:eq(roomIndex)] = number
	 end
      end
   end
   floorplanSegmentation[rooms:eq(backgroundRoomIndex)] = 0
   
   for _, icon in pairs(representation.icons) do   
      local number = utils.getNumber('icons', icon[3])
      floorplanSegmentation[{{math.max(math.min(icon[1][2], icon[2][2]), 1), math.min(math.max(icon[1][2], icon[2][2]), height)}, {math.max(math.min(icon[1][1], icon[2][1]), 1), math.min(math.max(icon[1][1], icon[2][1]), width)}}] = number + 10
      --[[
      local success, _ = pcall(function()
	    floorplanSegmentation[{{math.max(icon[1][2], 1), math.min(icon[2][2], height)}, {math.max(icon[1][1], 1), math.min(icon[2][1], width)}}] = number + 10
                               end
      )
      if not success then
         print(width)      
         print(height)      
         print(icon[1][1])      
         print(icon[1][2])      
         print(icon[2][1])      
         print(icon[2][2])      
	 end
      ]]--
   end
   floorplanSegmentation[rooms:eq(0)] = -1   

   --image.save('test/floorplan_segmentation.png', utils.drawSegmentation(floorplanSegmentation))
   --os.exit(1)
   local doorWidth = doorWidth or 3
   local doorMask = utils.drawLineMask(width, height, representation.doors, doorWidth)
   floorplanSegmentation[doorMask:byte()] = -2
   return floorplanSegmentation
end

function utils.parseFloorplan(floorplanInput)
   
   local binaryThreshold = 0.7
   
   --image.save('test/floorplan.png', floorplanInput)
   --image.save('test/floorplan_segmentation.png', ut.drawSegmentation(floorplanSegmentation, numSegments))
   --image.save('test/floorplan_binary.png', floorplanBinary)

   if borderSegmentReversed == 0 then
      return
   end
   
   local characterMasks = torch.cmul(1 - floorplanSegmentationReversed:eq(backgroundSegmentReversed), 1 - floorplanSegmentationReversed:eq(borderSegmentReversed))
   --image.save('test/invalid_mask_1.png', 1 - floorplanSegmentationReversed:eq(foregroundSegment))
   --image.save('test/invalid_mask_2.png', 1 - floorplanSegmentationReversed:eq(maxCountSegment))
   --image.save('test/character_masks.png', characterMasks:double())
   
   local borderMask = floorplanSegmentationReversed:eq(borderSegmentReversed)
   local borderIndices = borderMask:nonzero()
   local borderSegment = floorplanSegmentation[{borderIndices[1][1], borderIndices[1][2]}]

   --[[
      local borderThickness = 0
      local borderMaskEroded = borderMask:clone()
      while true do
      if ##borderMaskEroded:eq(1):nonzero() > 0 then
      borderMaskEroded = image.erode(borderMaskEroded)
      borderThickness = borderThickness + 2
      else
      borderThickness = borderThickness + 1
      break
      end
      end
   ]]--
   --print("borderThickness: " .. borderThickness)
   borderMask = image.dilate(borderMask)
   local floorplanSegmentationErodedOnce = torch.cmul(floorplanSegmentation, (1 - borderMask):int())
   --floorplanSegmentationErodedOnce = floorplanSegmentation:clone()
   
   --[[
      local numDilations = math.floor(borderThickness / 2)
      for i = 2, numDilations do
      borderMask = image.dilate(borderMask)
      end
      local floorplanSegmentationEroded = torch.cmul(floorplanSegmentation, (1 - borderMask):int())
   ]]--
   
   local floorplanSegmentationRefined = floorplanSegmentation:clone()
   local backgroundSegment = floorplanSegmentation[1][1]
   floorplanSegmentationRefined[floorplanSegmentation:eq(backgroundSegment)] = 1
   floorplanSegmentationRefined[floorplanSegmentation:eq(borderSegment)] = 0

   local segmentInfo = {
      mins = {},
      maxs = {},
      means = {},
      nums = {},
      samples = {},
   }
   for segment = 1, numSegments do   
      if segment ~= backgroundSegment and segment ~= borderSegment then
	 local indices = floorplanSegmentation:eq(segment):nonzero()     
         segmentInfo.mins[segment] = torch.min(indices, 1)[1]                    
         segmentInfo.maxs[segment] = torch.max(indices, 1)[1]                    
         segmentInfo.means[segment] = torch.mean(indices:double(), 1)[1]
         segmentInfo.nums[segment] = (#indices)[1]       
         segmentInfo.samples[segment] = indices[1]
      end
   end
   
   local largeSegments = {}
   local smallSegments = {}
   for segment = 1, numSegments do   
      if segment ~= backgroundSegment and segment ~= borderSegment then
         --if ##floorplanSegmentationEroded:eq(segment):nonzero() == 0 then
         --floorplanSegmentationRefined[floorplanSegmentation:eq(segment)] = 0
         if ##floorplanSegmentationErodedOnce:eq(segment):nonzero() > 0 and (#floorplanSegmentationErodedOnce:eq(segment):nonzero())[1] == segmentInfo.nums[segment] then          
            table.insert(smallSegments, segment)
         elseif segmentInfo.maxs[segment][1] - segmentInfo.mins[segment][1] < borderThickness or segmentInfo.maxs[segment][2] - segmentInfo.mins[segment][2] < borderThickness then
            floorplanSegmentationRefined[floorplanSegmentation:eq(segment)] = 0
         else
            table.insert(largeSegments, segment)
         end
      end
   end
   local characterSegmentsReversed = {}
   for segmentReversed = 1, numSegmentsReversed do            
      if segmentReversed ~= backgroundSegmentReversed and segmentReversed ~= borderSegmentReversed then         
         table.insert(characterSegmentsReversed, segmentReversed)
      end
   end
   --print(smallSegments)

   local characterSegmentInfo = {   
      mins = {},   
      maxs = {},   
      means = {},
      nums = {},
   }
   for _, characterSegmentReversed in pairs(characterSegmentsReversed) do
      local indices = floorplanSegmentationReversed:eq(characterSegmentReversed):nonzero()
      characterSegmentInfo.mins[characterSegmentReversed] = torch.min(indices, 1)[1]
      characterSegmentInfo.maxs[characterSegmentReversed] = torch.max(indices, 1)[1]      
      characterSegmentInfo.means[characterSegmentReversed] = torch.mean(indices:double(), 1)[1]
      characterSegmentInfo.means[characterSegmentReversed] = (#indices)[1]
   end

   for _, smallSegment in pairs(smallSegments) do
      local minDistance
      local minDistanceLargeSegment
      for _, largeSegment in pairs(largeSegments) do
         if segmentInfo.mins[smallSegment][1] >= segmentInfo.mins[largeSegment][1] and segmentInfo.mins[smallSegment][2] >= segmentInfo.mins[largeSegment][2] and segmentInfo.maxs[smallSegment][1] <= segmentInfo.maxs[largeSegment][1] and segmentInfo.maxs[smallSegment][2] <= segmentInfo.maxs[largeSegment][2] then
            local distance = torch.norm(segmentInfo.means[smallSegment] - segmentInfo.means[largeSegment])
            if minDistance == nil or distance < minDistance then
               minDistanceLargeSegment = largeSegment
               minDistance = distance
            end
         end
      end
      if minDistanceLargeSegment == nil then
         minDistanceLargeSegment = 1
      end
      floorplanSegmentationRefined[floorplanSegmentation:eq(smallSegment)] = minDistanceLargeSegment
   end

   for _, characterSegmentReversed in pairs(characterSegmentsReversed) do
      local minDistance
      local minDistanceLargeSegment
      for _, largeSegment in pairs(largeSegments) do
         if characterSegmentInfo.mins[characterSegmentReversed][1] >= segmentInfo.mins[largeSegment][1] and characterSegmentInfo.mins[characterSegmentReversed][2] >= segmentInfo.mins[largeSegment][2] and characterSegmentInfo.maxs[characterSegmentReversed][1] <= segmentInfo.maxs[largeSegment][1] and characterSegmentInfo.maxs[characterSegmentReversed][2] <= segmentInfo.maxs[largeSegment][2] then
            local distance = torch.norm(characterSegmentInfo.means[characterSegmentReversed] - segmentInfo.means[largeSegment])
            if minDistance == nil or distance < minDistance then
               minDistanceLargeSegment = largeSegment
               minDistance = distance
            end
         end
      end
      if minDistanceLargeSegment == nil then
         minDistanceLargeSegment = 1
      end
      floorplanSegmentationRefined[floorplanSegmentationReversed:eq(characterSegmentReversed)] = minDistanceLargeSegment
      characterMasks[floorplanSegmentationReversed:eq(characterSegmentReversed)] = minDistanceLargeSegment

   end

   --[[
      segmentInfo.indices = {}
      for _, largeSegment in pairs(largeSegments) do
      local indices = floorplanSegmentationRefined:eq(largeSegment):nonzero()
      segmentInfo.indices[largeSegment] = indices
      segmentInfo.mins[largeSegment] = torch.min(indices, 1)[1]            
      segmentInfo.maxs[largeSegment] = torch.max(indices, 1)[1]            
      segmentInfo.means[largeSegment] = torch.mean(indices:double(), 1)[1]
      segmentInfo.nums[largeSegment] = (#indices)[1]
      end
   ]]--

   local borderMask = floorplanSegmentationRefined:eq(0)
   borderMask[floorplanSegmentationRefined:eq(1)] = 1
   borderMask = image.erode(borderMask)
   local borderMaskByte = (borderMask * 255):byte()
   local floorplanSegmentationCoarse = torch.IntTensor(borderMaskByte:size())
   local numSegmentCoarse = cv.connectedComponents{255 - borderMaskByte, floorplanSegmentationCoarse}
   floorplanSegmentationCoarse = floorplanSegmentationCoarse + 1
   --image.save('test/floorplan_segmentation_coarse.png', ut.drawSegmentation(floorplanSegmentationCoarse, numSegmentCoarse))
   local coarseToFineSegmentMap = {}
   for segment = 1, numSegmentCoarse do
      coarseToFineSegmentMap[segment] = {}
   end
   for _, largeSegment in pairs(largeSegments) do
      table.insert(coarseToFineSegmentMap[floorplanSegmentationCoarse[segmentInfo.samples[largeSegment][1]][segmentInfo.samples[largeSegment][2]]], largeSegment)
   end
   for segmentCoarse = 1, numSegmentCoarse do
      local mins
      local maxs
      local maxNum
      local maxNumSegment
      local count = 0
      for _, largeSegment in pairs(coarseToFineSegmentMap[segmentCoarse]) do
         count = count + 1
         if maxNum == nil or segmentInfo.nums[largeSegment] > maxNum then
            maxNumSegment = largeSegment
            maxNum = segmentInfo.nums[largeSegment]
         end
         if mins == nil then
            mins = segmentInfo.mins[largeSegment]
            maxs = segmentInfo.maxs[largeSegment]
         else
            for i = 1, 2 do
               mins[i] = math.min(mins[i], segmentInfo.mins[largeSegment][i])
               maxs[i] = math.max(maxs[i], segmentInfo.maxs[largeSegment][i])
            end
         end
      end
      if count > 1 then
         local newSegmentWidth = maxs[1] - mins[1] + 1
         local newSegmentHeight = maxs[2] - mins[2] + 1
         local cornerMask = torch.zeros((#floorplanSegmentation)[1], (#floorplanSegmentation)[2])
         cornerMask:narrow(1, mins[1], newSegmentWidth):narrow(2, mins[2], newSegmentHeight):fill(1)
         cornerMask = torch.cmul(cornerMask:byte(), 1 - floorplanSegmentationCoarse:eq(segmentCoarse))
         cornerMask:narrow(1, segmentInfo.mins[maxNumSegment][1], segmentInfo.maxs[maxNumSegment][1] - segmentInfo.mins[maxNumSegment][1] + 1):narrow(2, segmentInfo.mins[maxNumSegment][2], segmentInfo.maxs[maxNumSegment][2] - segmentInfo.mins[maxNumSegment][2] + 1):fill(0)
         
         --local oriSegmentArea = (segmentInfo.maxs[maxNumSegment][1] - segmentInfo.mins[maxNumSegment][1] + 1) * (segmentInfo.maxs[maxNumSegment][2] - segmentInfo.mins[maxNumSegment][2] + 1)
         if ##cornerMask:nonzero() == 0 or (#cornerMask:nonzero())[1] < newSegmentWidth * newSegmentHeight * 0.1 then
            for _, largeSegment in pairs(coarseToFineSegmentMap[segmentCoarse]) do
               if largeSegment ~= maxNumSegment then
                  floorplanSegmentationRefined[floorplanSegmentationRefined:eq(largeSegment)] = maxNumSegment
                  characterMasks[characterMasks:eq(largeSegment)] = maxNumSegment
               end
            end
         end
      end
   end
   
   local newSegment = 1
   for segment = 1, numSegments do   
      if ##floorplanSegmentationRefined:eq(segment):nonzero() > 0 then   
         floorplanSegmentationRefined[floorplanSegmentationRefined:eq(segment)] = newSegment
         characterMasks[characterMasks:eq(segment)] = newSegment
         newSegment = newSegment + 1   
      end   
   end   
   local numSegmentsRefined = newSegment - 1
   return floorplanSegmentationRefined, characterMasks, numSegmentsRefined

end


return utils
